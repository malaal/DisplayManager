# DisplayManager

This component provides maangement of LED display hardware in an alarm clock. This module is designed to run as a thread/task under the system's RTOS, and is intended to be hardware-independent. The Manager is accessed by other parts of the firmware via a clear API.

As an RTOS task, the priority of this task relative to other tasks should be carefully decided. Since this task drives a UI that needs to feel responsive, and runs very little code when the task wakes (that is, it won't block other tasks), I would set the task with a relatively high priority. This is dependent on how long it takes the hardware driver to update the LED display.

## Assumptions

I am assuming a 24-hour clock since it was not mentioned in the design document. To use a 12-hour clock the LED display would need an additional AM/PM indicator.

The button that displays a single-digit number requires a source in the firmware but none is specified. In the interest of time, I have displayed a hard-coded value.

The module will require the RTOS to support a message queue that tasks can wait on for external commands (or internal timer expiration). I imagine something similar to FreeRTOS's Event Flags.

In lieu of RTOS timers, the module is driven by a synchronous, 1 second `tick()` function that drives various clock-based operaration. Other behaviors (related to button presses) are asynchronous. This tick should be called by the application code and generated by either the RTC hardware, or a hardware timer clocked from the 32kHz clock that also drives the RTC, to ensure synchronicity with the actual time.

The greater system as a whole:
 * Handles button input and debounces them using one or more of IRQs, timers, state machines, etc. When a button press/release is finalized, a call can will be made to DisplayManager (or any other component)
 * Has a realtime clock capable of generating interrupts every minute, which can be queried for the current time
 * Runs some high-level task or state machine to handle hardware events (ISR, RTC, comms, etc.) and call into modules as necessary
 * Has a driver for the LED display which is aware of its operation as a clock and takes inputs which have meaning as a clock. I have provided a mock driver function `updateDisplay` that demonstrates this. In the actual implementation, this code that intereprets the clock input and drives the LED could itself be another hardware-independent layer above the LED driver itself, so that the component can be changed out as needed.
 * Has another component called AlarmManager which can be queried for the state of the alarm. Presumably if the alarm is set, this is the component which will handle it. DisplayManager would need to be updated to provide the UX for alarm changes (and support for more buttons)

I have designed the module such that:
 * It manages the state of the display hardware internally
 * It provides a separate header/C file for externally-accessible calls (such as from the top-level state machine), and a header/c file for internal calls
 * The manager is started once after boot and runs throughout the life of the firmware

## Design Considerations / Alternatives

In the interest of time, errors are not properly handled or defined, or I have simplified them to a boolean result. This doesn't provide enough context to handle errors in most cases. In the final implementation, I'd have created an application- or module-level header file that defines the system's error return codes, and return those from all the manager/driver function calls instead. To imply this sort of error handling, I have specified in my code that FALSE is success and TRUE is an error. This is in line with using an error enum where 0 is generally "no error" and any other value is "some error".

The module could have been designed to be regularly polled, but as the code has very little to do (relative to other components) it wastes the system's time polling for no reason. Instead, using the event queue to wake the task when necessary provides the least overhead while remaining responsive to commands.

The timing of the DisplayManager is handled by a 1-second tick. This has the benefit of synchronizing the manager's default function (displaying the time) to the actual time, while also providing a free, low-overhead clock to drive other, limited-time actions of the display. Alternatively, the DisplayManager could have used an RTOS software timer to handle the special-display modes resetting back to the time, with perhaps a 1-second software timer to wake the task to check the clock and update it.

The design of the DisplayManager implies a simple state machine: clock, alarm, single-digit. I implemented this using a simple state enumeration, but if there's a larger set of state machine framework code used elsewhere in the firmware, it could be used here also.

